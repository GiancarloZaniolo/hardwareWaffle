OUTPUT_BASE_DIR = output
SIM_OUTPUT = $(OUTPUT_BASE_DIR)/simulation
SYNTH_OUTPUT = $(OUTPUT_BASE_DIR)/synthesis

# Default the output directory to the synthesis for synthesis targets
SYNTH_TARGETS = synth view-timing view-power view-area synth-clean
ifneq ($(filter $(SYNTH_TARGETS),$(MAKECMDGOALS)),)
    OUTPUT = $(SYNTH_OUTPUT)
else
    OUTPUT = $(SIM_OUTPUT)
endif
SYNTH_SCRIPT = dc/dc_synth.tcl
DEFAULT_LAB_18447 = 4b
LAB_18447 = $(DEFAULT_LAB_18447)
VALID_LABS = 1b 2 3 4a 4b
VALID_LABS_STRING = {1b, 2, 3, 4a, 4b}
SHELL = /bin/bash -o pipefail
CORES = $(shell getconf _NPROCESSORS_ONLN)
THREADS = $(shell echo $$((2 * $(CORES))))
SYNTH_CC = dc_shell-xg-t
DC_SCRIPT := $(shell readlink -m $(SYNTH_SCRIPT))
TIMING_REPORT = timing_riscv_core.rpt
POWER_REPORT = power_riscv_core.rpt
AREA_REPORT = area_riscv_core.rpt
REPORTS = $(TIMING_REPORT) $(POWER_REPORT) $(AREA_REPORT)
NETLIST = netlist_riscv_core.sv
SYNTH_REPORTS = $(addprefix $(OUTPUT)/,$(REPORTS) $(NETLIST))

# Log file for capturing the output of synthesis, stored in the output directory
SYNTH_LOG = synthesis.log

# The other files generated by DC synthesis
DC_FILES = work default.svf command.log
SYNTH_EXTRA_FILES = $(addprefix $(OUTPUT)/,$(DC_FILES) $(SYNTH_LOG))

# If the user specified a clock period, pass it to the DC script
ifneq ($(strip $(CLOCK_PERIOD)),)
    SET_CLOCK_PERIOD = ; set clock_period $(CLOCK_PERIOD)
endif
.PHONY: synth view-timing view-power view-area synth-clean synth-veryclean \
		synth-check-compiler synth-check-script

447_SRC = $(shell find -L . -type f \
		-name '*.v' -o -name '*.sv' -o -name '*.vh' | sort)

SRC = $(shell find -L . -type f \
		-name '*.v' -o -name '*.sv' -o -name '*.vh' | sort)
$(OUTPUT):
	@mkdir -p $@

# User-facing target to synthesize the processor into a physical design
synth: $(SYNTH_REPORTS)

# View the timing report from synthesis. If it doesn't exist, run synthesis.
view-timing:
	@if [ ! -e $(OUTPUT)/$(TIMING_REPORT) ]; then \
		make OUTPUT=$(OUTPUT) SYNTH_SCRIPT=$(SYNTH_SCRIPT) synth; \
	fi
	@printf "$uTiming Report: $(OUTPUT)/$(TIMING_REPORT):$n\n\n"
	@cat $(OUTPUT)/$(TIMING_REPORT)

# View the power report from synthesis. If it doesn't exist, run synthesis.
view-power:
	@if [ ! -e $(OUTPUT)/$(POWER_REPORT) ]; then \
		make OUTPUT=$(OUTPUT) SYNTH_SCRIPT=$(SYNTH_SCRIPT) synth; \
	fi
	@printf "$uPower Report: $(OUTPUT)/$(POWER_REPORT):$n\n\n"
	@cat $(OUTPUT)/$(POWER_REPORT)

# View the area report from synthesis. If it doesn't exist, run synthesis.
view-area:
	@if [ ! -e $(OUTPUT)/$(AREA_REPORT) ]; then \
		make OUTPUT=$(OUTPUT) SYNTH_SCRIPT=$(SYNTH_SCRIPT) synth; \
	fi
	@printf "$uArea Report: $(OUTPUT)/$(AREA_REPORT):$n\n\n"
	@cat $(OUTPUT)/$(AREA_REPORT)

# Synthesize the processor into a physical design, generating reports on its
# area, timing, and power
$(SYNTH_REPORTS): $(447_SRC) $(SRC) $(DC_SCRIPT) | $(OUTPUT) \
			synth-check-compiler synth-check-script
	@printf "Synthesizing design in $u$(OUTPUT)$n..."
	@cd $(OUTPUT) && $(SYNTH_CC) -f $(DC_SCRIPT) -x "set project_dir $(PWD);  \
		set lab_18447 $(LAB_18447)$(SET_CLOCK_PERIOD)" |& tee $(SYNTH_LOG)
	@printf "\nSynthesis has completed. The synthesis log can be found at "
	@printf "$u$(OUTPUT)/$(SYNTH_LOG)$n\n"
	@printf "The timing report can be found at $u$(OUTPUT)/$(TIMING_REPORT)$n\n"
	@printf "The power report can be found at $u$(OUTPUT)/$(POWER_REPORT)$n\n"
	@printf "The area report can be found at $u$(OUTPUT)/$(AREA_REPORT)$n\n"
	@if grep -i latch $(OUTPUT)/$(SYNTH_LOG) &> /dev/null; then \
		printf "\n\n\n\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX   Found disallowed latch inference. \n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX   grep -i latch $(OUTPUT)/$(SYNTH_LOG)  \n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
		printf "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"; \
	else \
		printf "No latches found in $u$(OUTPUT)/$(SYNTH_LOG)$n\n"; \
	fi 


# Clean up all the files generated by DC synthesis
synth-clean:
	@printf "Cleaning up synthesis files...\n"
	@rm -rf $(SYNTH_REPORTS) $(SYNTH_EXTRA_FILES)

# Very clean is the same as clean for synthesis
synth-veryclean: synth-clean

# Suppresses 'no rule to make...' error when the DC_SCRIPT doesn't exist
$(DC_SCRIPT):

# Check that the Verilog synthesis compiler exists
synth-check-compiler:
ifeq ($(shell which $(SYNTH_CC) 2> /dev/null),)
	@printf "$rError: $u$(SYNTH_CC)$n$r: Verilog synthesis compiler was not "
	@printf "found in your $bPATH$n$r.\n$n"
	@exit 1
endif

# Check that script used for synthesis exists
synth-check-script:
ifeq ($(wildcard $(SYNTH_SCRIPT)),)
	@printf "$rError: $u$(SYNTH_SCRIPT)$n$r: DC synthesis script does not "
	@printf "exist.\n$n"
	@exit 1
endif

# Target executable
TARGET = simv

# Source files
MY_SRC = $(wildcard *.sv) $(wildcard *.v)

# Set the number of threads to use for parallel compilation (2 * cores)
CORES = $(shell getconf _NPROCESSORS_ONLN)
THREADS = $(shell echo $$((2 * $(CORES))))

# Vlogan flags
VLOGANFLAGS = -full64 -sverilog -debug_all +lint=all,noVCDE +warn=all \
					 -timescale=1ns/1ps +v2k -msg_config=vcs_config

VCSUUMFLAGS = -full64 -sverilog -debug_all +lint=all,noVCDE +warn=all \
					 -timescale=1ns/1ps

# VCS flags
VCSFLAGS = -full64 -sverilog -debug_all +lint=all,noVCDE +warn=all -j$(THREADS) \
					 -timescale=1ns/1ps +v2k
COMMON_FLAGS +=

# Simulator
SIM = vcs

# Altera FPGA library files (for simulation)
INC_V = /afs/ece/support/altera/release/16.1.2/quartus/eda/sim_lib/altera_primitives.v \
				/afs/ece/support/altera/release/16.1.2/quartus/eda/sim_lib/220model.v \
				/afs/ece/support/altera/release/16.1.2/quartus/eda/sim_lib/sgate.v \
				/afs/ece/support/altera/release/16.1.2/quartus/eda/sim_lib/altera_mf.v \
				/afs/ece/support/altera/release/16.1.2/quartus/eda/sim_lib/cyclonev_atoms.v
INC_V_FLAGS = $(addprefix -v , $(INC_V))
INC_SV =
INC_SV_FLAGS = $(addprefix -v , $(INC_SV))

# Copy common flags
VCSFLAGS += $(COMMON_FLAGS)

default : $(MY_SRC)
	$(SIM) $(VCSFLAGS) $(INC_V_FLAGS) $(INC_SV_FLAGS) -o $(TARGET) $(MY_SRC)

waffle : 
	python3 mif_gen.py 512 32 16384 256

verified_waffle :
	python3 gen_and_solve.py 512 32 16384 256

clean :
	-rm -r csrc
	-rm -r DVEfiles
	-rm $(TARGET)
	-rm -r $(TARGET).daidir
	-rm ucli.key
	-rm *.mif
	@rm -rf $(OUTPUT)
	@rm -rf $(OUTPUT_BASE_DIR)

MODULE?=TB
